local a={}a.ClassName="Maid"function a.new()return setmetatable({_tasks={}},a)end;function a.isMaid(b)return type(b)=="table"and b.ClassName=="Maid"end;function a:__index(c)if a[c]then return a[c]else return self._tasks[c]end end;function a:__newindex(c,d)if a[c]~=nil then error(("'%s' is reserved"):format(tostring(c)),2)end;local e=self._tasks;local f=e[c]if f==d then return end;e[c]=d;if f then if type(f)=="function"then f()elseif typeof(f)=="RBXScriptConnection"then f:Disconnect()elseif f.Destroy then f:Destroy()end end end;function a:GiveTask(task)if not task then error("Task cannot be false or nil",2)end;local g=#self._tasks+1;self[g]=task;if type(task)=="table"and not task.Destroy then warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n"..debug.traceback())end;return g end;function a:GivePromise(h)if not h:IsPending()then return h end;local i=h.resolved(h)local j=self:GiveTask(i)i:Finally(function()self[j]=nil end)return i end;function a:DoCleaning()local e=self._tasks;for c,task in pairs(e)do if typeof(task)=="RBXScriptConnection"then e[c]=nil;task:Disconnect()end end;local c,task=next(e)while task~=nil do e[c]=nil;if type(task)=="function"then task()elseif typeof(task)=="RBXScriptConnection"then task:Disconnect()elseif task.Destroy then task:Destroy()end;c,task=next(e)end end;a.Destroy=a.DoCleaning;local k=game:GetService("HttpService")local l=false;local m={}m.__index=m;m.ClassName="Signal"function m.new()local self=setmetatable({},m)self._bindableEvent=Instance.new("BindableEvent")self._argMap={}self._source=l and debug.traceback()or""self._bindableEvent.Event:Connect(function(n)self._argMap[n]=nil;if not self._bindableEvent and not next(self._argMap)then self._argMap=nil end end)return self end;function m:Fire(...)if not self._bindableEvent then warn(("Signal is already destroyed. %s"):format(self._source))return end;local o=table.pack(...)local n=k:GenerateGUID(false)self._argMap[n]=o;self._bindableEvent:Fire(n)end;function m:Connect(p)if not(type(p)=="function")then error(("connect(%s)"):format(typeof(p)),2)end;return self._bindableEvent.Event:Connect(function(n)local o=self._argMap[n]if o then p(table.unpack(o,1,o.n))else error("Missing arg data, probably due to reentrance.")end end)end;function m:Wait()local n=self._bindableEvent.Event:Wait()local o=self._argMap[n]if o then return table.unpack(o,1,o.n)else error("Missing arg data, probably due to reentrance.")return nil end end;function m:Destroy()if self._bindableEvent then self._bindableEvent:Destroy()self._bindableEvent=nil end;setmetatable(self,nil)end;local q={}local r=string.format;function q:sendNotif(s,t,u,v,w,x)game:GetService("StarterGui"):SetCore("SendNotification",{Title="Animator",Text=s.."\nBy hayper#0001"or nil,Icon=t or nil,Duration=u or nil,Button1=v or nil,Button2=w or nil,Callback=x or nil})end;local y={["PoseEasingDirection"]="EasingDirection",["PoseEasingStyle"]="EasingStyle"}function q:convertEnum(z)local A=tostring(z):split(".")if A[1]=="Enum"then local B=A[2]local C=A[3]C=C=="Constant"and"Linear"or C;if y[B]then return Enum[y[B]][C]else return z end else return z end end;function q:getBones(D,E)E=E or{IgnoreIn={},IgnoreList={}}if typeof(D)~="Instance"then error(r("invalid argument 1 to 'getBones' (Instance expected, got %s)",typeof(D)))end;local F={}local G=D:GetDescendants()for H=1,#G do local I=G[H]if not I:IsA("Bone")then continue end;local J=false;for K=1,#E.IgnoreList do local L=E.IgnoreIn[K]if typeof(L)=="Instance"and(table.find(E.IgnoreList,I)or I:IsDescendantOf(L))then J=true;break end end;if not J then table.insert(F,I)end end;return F end;function q:getMotors(D,E)E=E or{IgnoreIn={},IgnoreList={}}if typeof(D)~="Instance"then error(r("invalid argument 1 to 'getMotors' (Instance expected, got %s)",typeof(D)))end;local M={}local G=D:GetDescendants()for H=1,#G do local I=G[H]if not I:IsA("Motor6D")then continue end;local J=false;for K=1,#E.IgnoreList do local L=E.IgnoreIn[K]if typeof(L)=="Instance"and(table.find(E.IgnoreList,I)or I:IsDescendantOf(L))then J=true;break end end;if not J then table.insert(M,I)end end;return M end;local N={}function N:parsePoseData(O)if not O:IsA("Pose")then error(r("invalid argument 1 to 'parsePoseData' (Pose expected, got %s)",O.ClassName))end;local P={Name=O.Name,CFrame=O.CFrame,EasingDirection=q:convertEnum(O.EasingDirection),EasingStyle=q:convertEnum(O.EasingStyle),Weight=O.Weight}if#O:GetChildren()>0 then P.Subpose={}local Q=O:GetChildren()for H=1,#Q do local B=Q[H]if not B:IsA("Pose")then continue end;table.insert(P.Subpose,N:parsePoseData(B))end end;return P end;function N:parseKeyframeData(R)if not R:IsA("Keyframe")then error(r("invalid argument 1 to 'parseKeyframeData' (Keyframe expected, got %s)",R.ClassName))end;local S={Name=R.Name,Time=R.Time,Pose={}}local Q=R:GetChildren()for H=1,#Q do local B=Q[H]if B:IsA("Pose")then table.insert(S.Pose,N:parsePoseData(B))elseif B:IsA("KeyframeMarker")then if not S["Marker"]then S.Marker={}end;if not S.Marker[B.Name]then S.Marker[B.Name]={}end;table.insert(S.Marker[B.Name],B.Value)end end;return S end;function N:parseAnimationData(T)if not T:IsA("KeyframeSequence")then error(r("invalid argument 1 to 'parseAnimationData' (KeyframeSequence expected, got %s)",T.ClassName))end;local U={Loop=T.Loop,Priority=T.Priority,Frames={}}local Q=T:GetChildren()for H=1,#Q do local V=Q[H]if not V:IsA("Keyframe")then continue end;table.insert(U.Frames,N:parseKeyframeData(V))end;table.sort(U.Frames,function(W,X)return W.Time<X.Time end)return U end;local Y=game:GetService("TweenService")local Z={AnimationData={},BoneIgnoreInList={},MotorIgnoreInList={},BoneIgnoreList={},MotorIgnoreList={},handleVanillaAnimator=true,Character=nil,Looped=false,Length=0,Speed=1,IsPlaying=false,_stopFadeTime=0.100000001,_playing=false,_stopped=false,_isLooping=false,_markerSignal={}}local _,a0=CFrame.new,CFrame.Angles;local a1=math.deg;local a2=os.clock;local r=string.format;local a3=_()local a4=a3*a0(a1(0),a1(0),a1(0))Z.__index=Z;function Z.new(D,a5)if typeof(D)~="Instance"then error(r("invalid argument 1 to 'new' (Instace expected, got %s)",typeof(D)))end;local self=setmetatable({},Z)if typeof(a5)=="string"or typeof(a5)=="number"then local a6=game:GetObjects("rbxassetid://"..tostring(a5))[1]if not a6:IsA("KeyframeSequence")then error("invalid argument 1 to 'new' (AnimationID expected)")end;self.AnimationData=N:parseAnimationData(a6)elseif typeof(a5)=="table"then self.AnimationData=a5 elseif typeof(a5)=="Instance"then if a5:IsA("KeyframeSequence")then self.AnimationData=N:parseAnimationData(a5)elseif a5:IsA("Animation")then local a6=game:GetObjects(a5.AnimationId)[1]if not a6:IsA("KeyframeSequence")then error("invalid argument 1 to 'new' (AnimationID inside Animation expected)")end;self.AnimationData=N:parseAnimationData(a6)end else error(r("invalid argument 2 to 'new' (number,string,table,Instance expected, got %s)",typeof(a5)))end;self.Character=D;self.Looped=self.AnimationData.Loop;self.Length=self.AnimationData.Frames[#self.AnimationData.Frames].Time;self._maid=a.new()self.DidLoop=m.new()self.Stopped=m.new()self.KeyframeReached=m.new()self._maid.DidLoop=self.DidLoop;self._maid.Stopped=self.Stopped;self._maid.KeyframeReached=self.KeyframeReached;return self end;function Z:IgnoreMotor(a7)if typeof(a7)~="Instance"then error(r("invalid argument 1 to 'IgnoreMotor' (Instance expected, got %s)",typeof(a7)))end;if a7.ClassName~="Motor6D"then error(r("invalid argument 1 to 'IgnoreMotor' (Motor6D expected, got %s)",a7.ClassName))end;table.insert(self.MotorIgnoreList,a7)end;function Z:IgnoreBone(a7)if typeof(a7)~="Instance"then error(r("invalid argument 1 to 'IgnoreBone' (Instance expected, got %s)",typeof(a7)))end;if a7.ClassName~="Bone"then error(r("invalid argument 1 to 'IgnoreBone' (Bone expected, got %s)",a7.ClassName))end;table.insert(self.BoneIgnoreList,a7)end;function Z:IgnoreMotorIn(a7)if typeof(a7)~="Instance"then error(r("invalid argument 1 to 'IgnoreMotorIn' (Instance expected, got %s)",typeof(a7)))end;table.insert(self.MotorIgnoreInList,a7)end;function Z:IgnoreBoneIn(a7)if typeof(a7)~="Instance"then error(r("invalid argument 1 to 'IgnoreBoneIn' (Instance expected, got %s)",typeof(a7)))end;table.insert(self.BoneIgnoreInList,a7)end;function Z:_playPose(O,a8,a9)local M=q:getMotors(self.Character,{IgnoreIn=self.MotorIgnoreInList,IgnoreList=self.MotorIgnoreList})local F=q:getBones(self.Character,{IgnoreIn=self.BoneIgnoreInList,IgnoreList=self.BoneIgnoreList})if O.Subpose then local aa=O.Subpose;for H=1,#aa do local ab=aa[H]self:_playPose(ab,O,a9)end end;if not a8 then return end;local ac=TweenInfo.new(a9,O.EasingStyle,O.EasingDirection)task.spawn(function()for H=1,#M do local ad=M[H]if ad.Part0.Name~=a8.Name or ad.Part1.Name~=O.Name then continue end;if not self or self._stopped then break end;if a9>0 then Y:Create(ad,ac,{Transform=O.CFrame}):Play()else ad.Transform=O.CFrame end end end)task.spawn(function()for H=1,#F do local ae=F[H]if a8.Name~=ae.Parent.Name or ae.Name~=O.Name then continue end;if not self or self._stopped then break end;if a9>0 then Y:Create(ae,ac,{Transform=O.CFrame}):Play()else ae.Transform=O.CFrame end end end)end;function Z:Play(af,ag,ah)af=af or 0.100000001;if not self.Character or self.Character.Parent==nil or self._playing and not self._isLooping then return end;self._playing=true;self._isLooping=false;self.IsPlaying=true;local ai;local aj;if self.Character:FindFirstChild("Humanoid")then ai=self.Character.Humanoid.Died:Connect(function()self:Destroy()ai:Disconnect()end)if self.handleVanillaAnimator and self.Character.Humanoid:FindFirstChild("Animator")then self.Character.Humanoid.Animator:Destroy()end end;aj=self.Character:GetPropertyChangedSignal("Parent"):Connect(function()if self~=nil and self.Character.Parent~=nil then return end;self:Destroy()aj:Disconnect()end)local ak=a2()task.spawn(function()for I=1,#self.AnimationData.Frames do if self._stopped then break end;local V=self.AnimationData.Frames[I]local al=V.Time/(ah or self.Speed)if V.Name~="Keyframe"then self.KeyframeReached:Fire(V.Name)end;if V["Marker"]then for am,C in next,V.Marker do if not self._markerSignal[am]then continue end;for an,ao in next,C do self._markerSignal[am]:Fire(ao)end end end;if V.Pose then local ap=V.Pose;for H=1,#ap do local B=ap[H]local aq=af;if I~=1 then aq=(al*(ah or self.Speed)-self.AnimationData.Frames[I-1].Time)/(ah or self.Speed)end;self:_playPose(B,nil,aq)end end;if al>a2()-ak then repeat task.wait()until self._stopped or a2()-ak>=al end end;if ai then ai:Disconnect()end;if aj then aj:Disconnect()end;if self.Looped and not self._stopped then self.DidLoop:Fire()self._isLooping=true;return self:Play(af,ag,ah)end;task.wait()local ac=TweenInfo.new(self._stopFadeTime or af,Enum.EasingStyle.Cubic,Enum.EasingDirection.InOut)if self.Character then local M=q:getMotors(self.Character,{IgnoreIn=self.MotorIgnoreInList,IgnoreList=self.MotorIgnoreList})local F=q:getBones(self.Character,{IgnoreIn=self.BoneIgnoreInList,IgnoreList=self.BoneIgnoreList})for H=1,#M do local X=M[H]if(self._stopFadeTime or af)>0 then Y:Create(X,ac,{Transform=a3,CurrentAngle=0}):Play()else X.CurrentAngle=0;X.Transform=a3 end end;for H=1,#F do local ar=F[H]if(self._stopFadeTime or af)>0 then Y:Create(ar,ac,{Transform=a4}):Play()else ar.Transform=a4 end end;if self.handleVanillaAnimator and self.Character:FindFirstChild("Humanoid")and not self.Character.Humanoid:FindFirstChildOfClass("Animator")then Instance.new("Animator").Parent=self.Character.Humanoid end end;self._stopped=false;self._playing=false;self.IsPlaying=false;self.Stopped:Fire()end)end;function Z:GetTimeOfKeyframe(as)for H=1,#self.AnimationData.Frames do local V=self.AnimationData.Frames[H]if V.Name~=as then continue end;return V.Time end;return 0 end;function Z:GetMarkerReachedSignal(at)if not self._markerSignal[at]then self._markerSignal[at]=m.new()self._maid["Marker_"..at]=self._markerSignal[at]end;return self._markerSignal[at]end;function Z:AdjustSpeed(ah)self.Speed=ah end;function Z:Stop(af)self._stopFadeTime=af or 0.100000001;self._stopped=true end;function Z:Destroy()self:Stop(0)self.Stopped:Wait()self._maid:DoCleaning()end;getgenv().Animator=Z;getgenv().hookAnimatorFunction=function()local au;au=hookmetamethod(game,"__namecall",function(av,...)local aw=getnamecallmethod()if not checkcaller()or av.ClassName~="Humanoid"or aw~="LoadAnimation"then return au(av,...)end;local o={...}if not o[2]or o[2]==true then return au(av,...)end;return Z.new(av.Parent,...)end)q:sendNotif("Hook Loaded\nby whited#4382",nil,5)end;q:sendNotif("API Loaded",nil,5)return"Nullware my beloved <3"