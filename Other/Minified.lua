local a={}a.ClassName="Maid"function a.new()return setmetatable({_tasks={}},a)end;function a.isMaid(b)return type(b)=="table"and b.ClassName=="Maid"end;function a:__index(c)if a[c]then return a[c]else return self._tasks[c]end end;function a:__newindex(c,d)if a[c]~=nil then error(("'%s' is reserved"):format(tostring(c)),2)end;local e=self._tasks;local f=e[c]if f==d then return end;e[c]=d;if f then if type(f)=="function"then f()elseif typeof(f)=="RBXScriptConnection"then f:Disconnect()elseif f.Destroy then f:Destroy()end end end;function a:GiveTask(task)if not task then error("Task cannot be false or nil",2)end;local g=#self._tasks+1;self[g]=task;if type(task)=="table"and not task.Destroy then warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n"..debug.traceback())end;return g end;function a:GivePromise(h)if not h:IsPending()then return h end;local i=h.resolved(h)local j=self:GiveTask(i)i:Finally(function()self[j]=nil end)return i end;function a:DoCleaning()local e=self._tasks;for c,task in pairs(e)do if typeof(task)=="RBXScriptConnection"then e[c]=nil;task:Disconnect()end end;local c,task=next(e)while task~=nil do e[c]=nil;if type(task)=="function"then task()elseif typeof(task)=="RBXScriptConnection"then task:Disconnect()elseif task.Destroy then task:Destroy()end;c,task=next(e)end end;a.Destroy=a.DoCleaning;local k=game:GetService("HttpService")local l=false;local m={}m.__index=m;m.ClassName="Signal"function m.new()local self=setmetatable({},m)self._bindableEvent=Instance.new("BindableEvent")self._argMap={}self._source=l and debug.traceback()or""self._bindableEvent.Event:Connect(function(n)self._argMap[n]=nil;if not self._bindableEvent and not next(self._argMap)then self._argMap=nil end end)return self end;function m:Fire(...)if not self._bindableEvent then warn(("Signal is already destroyed. %s"):format(self._source))return end;local o=table.pack(...)local n=k:GenerateGUID(false)self._argMap[n]=o;self._bindableEvent:Fire(n)end;function m:Connect(p)if not(type(p)=="function")then error(("connect(%s)"):format(typeof(p)),2)end;return self._bindableEvent.Event:Connect(function(n)local o=self._argMap[n]if o then p(table.unpack(o,1,o.n))else error("Missing arg data, probably due to reentrance.")end end)end;function m:Wait()local n=self._bindableEvent.Event:Wait()local o=self._argMap[n]if o then return table.unpack(o,1,o.n)else error("Missing arg data, probably due to reentrance.")return nil end end;function m:Destroy()if self._bindableEvent then self._bindableEvent:Destroy()self._bindableEvent=nil end;setmetatable(self,nil)end;local q=string.format;function sendNotif(r,s,t,u,v,w)game:GetService("StarterGui"):SetCore("SendNotification",{Title="Animator",Text=r.."\nBy hayper#0001"or nil,Icon=s or nil,Duration=t or nil,Button1=u or nil,Button2=v or nil,Callback=w or nil})end;function convertEnum(x)local y=tostring(x):split(".")if y[1]=="Enum"then local z=y[2]local A=y[3]local B={["PoseEasingDirection"]="EasingDirection",["PoseEasingStyle"]="EasingStyle"}if B[z]then return Enum[B[z]][A]else return x end else return x end end;function getBones(C,D)D=D or{}if typeof(C)~="Instance"then error(q("invalid argument 1 to 'getBones' (Instance expected, got %s)",typeof(C)))end;if typeof(D)~="table"then error(q("invalid argument 1 to 'getBones' (Table expected, got %s)",typeof(D)))end;local E={}local F=C:GetDescendants()for G=1,#F do local H=F[G]if not H:IsA("Bone")then continue end;local I=false;for J=1,#D do local K=D[J]if typeof(K)=="Instance"and H:IsDescendantOf(K)then I=true;break end end;if not I then table.insert(E,H)end end;return E end;function getMotors(C,D)D=D or{}if typeof(C)~="Instance"then error(q("invalid argument 1 to 'getMotors' (Instance expected, got %s)",typeof(C)))end;if typeof(D)~="table"then error(q("invalid argument 1 to 'getMotors' (Table expected, got %s)",typeof(D)))end;local L={}local F=C:GetDescendants()for G=1,#F do local H=F[G]if not H:IsA("Motor6D")or H.Part0==nil or H.Part1==nil then continue end;local I=false;for J=1,#D do local K=D[J]if typeof(K)=="Instance"and H:IsDescendantOf(K)then I=true;break end end;if not I then table.insert(L,H)end end;return L end;function parsePoseData(M)if not M:IsA("Pose")then error(q("invalid argument 1 to 'parsePoseData' (Pose expected, got %s)",M.ClassName))end;local N={Name=M.Name,CFrame=M.CFrame,EasingDirection=convertEnum(M.EasingDirection),EasingStyle=convertEnum(M.EasingStyle),Weight=M.Weight}if#M:GetChildren()>0 then N.Subpose={}local O=M:GetChildren()for G=1,#O do local z=O[G]if not z:IsA("Pose")then continue end;table.insert(N.Subpose,parsePoseData(z))end end;return N end;function parseKeyframeData(P)if not P:IsA("Keyframe")then error(q("invalid argument 1 to 'parseKeyframeData' (Keyframe expected, got %s)",P.ClassName))end;local Q={Name=P.Name,Time=P.Time,Pose={}}local O=P:GetChildren()for G=1,#O do local z=O[G]if z:IsA("Pose")then table.insert(Q.Pose,parsePoseData(z))elseif z:IsA("KeyframeMarker")then if not Q["Marker"]then Q.Marker={}end;if not Q.Marker[z.Name]then Q.Marker[z.Name]={}end;table.insert(Q.Marker,z.Name)end end;return Q end;function parseAnimationData(R)if not R:IsA("KeyframeSequence")then error(q("invalid argument 1 to 'parseAnimationData' (KeyframeSequence expected, got %s)",R.ClassName))end;local S={Loop=R.Loop,Priority=R.Priority,Frames={}}local O=R:GetChildren()for G=1,#O do local T=O[G]if not T:IsA("Keyframe")then continue end;table.insert(S.Frames,parseKeyframeData(T))end;table.sort(S.Frames,function(U,V)return U.Time<V.Time end)return S end;local W=game:GetService("TweenService")local X={AnimationData={},handleVanillaAnimator=true,Character=nil,Looped=false,Length=0,Speed=1,IsPlaying=false,_motorIgnoreList={},_stopFadeTime=0.100000001,_playing=false,_stopped=false,_isLooping=false,_markerSignal={},_boneIgnoreList={}}local Y,Z=CFrame.new,CFrame.Angles;local _=math.deg;local a0=os.clock;local q=string.format;local a1=Y()local a2=a1*Z(_(0),_(0),_(0))X.__index=X;function X.new(C,a3)if typeof(C)~="Instance"then error(q("invalid argument 1 to 'new' (Instace expected, got %s)",typeof(C)))end;local self=setmetatable({},X)if typeof(a3)=="string"or typeof(a3)=="number"then local a4=game:GetObjects("rbxassetid://"..tostring(a3))[1]if not a4:IsA("KeyframeSequence")then error("invalid argument 1 to 'new' (AnimationID expected)")end;self.AnimationData=Parser:parseAnimationData(a4)elseif typeof(a3)=="table"then self.AnimationData=a3 elseif typeof(a3)=="Instance"then if a3:IsA("KeyframeSequence")then self.AnimationData=Parser:parseAnimationData(a3)elseif a3:IsA("Animation")then local a4=game:GetObjects(a3.AnimationId)[1]if not a4:IsA("KeyframeSequence")then error("invalid argument 1 to 'new' (AnimationID inside Animation expected)")end;self.AnimationData=Parser:parseAnimationData(a4)end else error(q("invalid argument 2 to 'new' (number,string,table,Instance expected, got %s)",typeof(a3)))end;self.Character=C;self.Looped=self.AnimationData.Loop;self.Length=self.AnimationData.Frames[#self.AnimationData.Frames].Time;self._maid=a.new()self.DidLoop=m.new()self.Stopped=m.new()self.KeyframeReached=m.new()self._maid.DidLoop=self.DidLoop;self._maid.Stopped=self.Stopped;self._maid.KeyframeReached=self.KeyframeReached;return self end;function X:IgnoreMotorIn(a5)if typeof(a5)~="table"then error(q("invalid argument 1 to 'IgnoreMotorIn' (Table expected, got %s)",typeof(a5)))end;self._motorIgnoreList=a5 end;function X:GetMotorIgnoreList()return self._motorIgnoreList end;function X:IgnoreBoneIn(a5)if typeof(a5)~="table"then error(q("invalid argument 1 to 'IgnoreBoneIn' (Table expected, got %s)",typeof(a5)))end;self._boneIgnoreList=a5 end;function X:GetBoneIgnoreList()return self._boneIgnoreList end;function X:_playPose(M,a6,a7)local L=Utility:getMotors(self.Character,self._motorIgnoreList)local E=Utility:getBones(self.Character,self._boneIgnoreList)if M.Subpose then local a8=M.Subpose;for G=1,#a8 do local a9=a8[G]self:_playPose(a9,M,a7)end end;if not a6 then return end;local aa=TweenInfo.new(a7,M.EasingStyle,M.EasingDirection)task.spawn(function()for G=1,#L do local ab=L[G]if ab.Part0.Name~=a6.Name or ab.Part1.Name~=M.Name then continue end;if self==nil or self._stopped then break end;if a7>0 then W:Create(ab,aa,{Transform=M.CFrame}):Play()else ab.Transform=M.CFrame end end end)task.spawn(function()for G=1,#E do local ac=E[G]if a6.Name~=ac.Parent.Name or ac.Name~=M.Name then continue end;if self==nil or self._stopped then break end;if a7>0 then W:Create(ac,aa,{Transform=M.CFrame}):Play()else ac.Transform=M.CFrame end end end)end;function X:Play(ad,ae,af)ad=ad or 0.100000001;if not self.Character or self.Character.Parent==nil or self._playing and not self._isLooping then return end;self._playing=true;self._isLooping=false;self.IsPlaying=true;local ag;local ah;if self.Character:FindFirstChild("Humanoid")then ag=self.Character.Humanoid.Died:Connect(function()self:Destroy()ag:Disconnect()end)if self.handleVanillaAnimator and self.Character.Humanoid:FindFirstChild("Animator")then self.Character.Humanoid.Animator:Destroy()end end;ah=self.Character:GetPropertyChangedSignal("Parent"):Connect(function()if self~=nil and self.Character.Parent~=nil then return end;self:Destroy()ah:Disconnect()end)local ai=a0()task.spawn(function()for H=1,#self.AnimationData.Frames do if self._stopped then break end;local T=self.AnimationData.Frames[H]local aj=T.Time/(af or self.Speed)if T.Name~="Keyframe"then self.KeyframeReached:Fire(T.Name)end;if T["Marker"]then for ak,A in next,T.Marker do if not self._markerSignal[ak]then continue end;self._markerSignal[ak]:Fire(A)end end;if T.Pose then local al=T.Pose;for G=1,#al do local z=al[G]local am=ad;if H~=1 then am=(aj*(af or self.Speed)-self.AnimationData.Frames[H-1].Time)/(af or self.Speed)end;self:_playPose(z,nil,am)end end;if aj>a0()-ai then repeat task.wait()until self._stopped or a0()-ai>=aj end end;if ag then ag:Disconnect()end;if ah then ah:Disconnect()end;if self.Looped and not self._stopped then self.DidLoop:Fire()self._isLooping=true;return self:Play(ad,ae,af)end;task.wait()local aa=TweenInfo.new(self._stopFadeTime or ad,Enum.EasingStyle.Cubic,Enum.EasingDirection.InOut)if self.Character then local L=Utility:getMotors(self.Character,self._motorIgnoreList)local E=Utility:getBones(self.Character,self._boneIgnoreList)for G=1,#L do local V=L[G]if(self._stopFadeTime or ad)>0 then W:Create(V,aa,{Transform=a1,CurrentAngle=0}):Play()else V.CurrentAngle=0;V.Transform=a1 end end;for G=1,#E do local an=E[G]if(self._stopFadeTime or ad)>0 then W:Create(an,aa,{Transform=a2}):Play()else an.Transform=a2 end end;if self.handleVanillaAnimator and self.Character:FindFirstChild("Humanoid")and not self.Character.Humanoid:FindFirstChildOfClass("Animator")then Instance.new("Animator").Parent=self.Character.Humanoid end end;self._stopped=false;self._playing=false;self.IsPlaying=false;self.Stopped:Fire()end)end;function X:GetTimeOfKeyframe(ao)for G=1,#self.AnimationData.Frames do local T=self.AnimationData.Frames[G]if T.Name~=ao then continue end;return T.Time end;return 0 end;function X:GetMarkerReachedSignal(ap)if not self._markerSignal[ap]then self._markerSignal[ap]=m.new()self._maid["Marker_"..ap]=self._markerSignal[ap]end;return self._markerSignal[ap]end;function X:AdjustSpeed(af)self.Speed=af end;function X:Stop(ad)self._stopFadeTime=ad or 0.100000001;self._stopped=true end;function X:Destroy()self:Stop(0)self.Stopped:Wait()self._maid:DoCleaning()end;getgenv().Animator=X;getgenv().hookAnimatorFunction=function()local aq;aq=hookmetamethod(game,"__namecall",function(ar,...)local as=getnamecallmethod()if not checkcaller()or ar.ClassName~="Humanoid"or as~="LoadAnimation"then return aq(ar,...)end;local o={...}if not o[2]or o[2]==true then return aq(ar,...)end;return X.new(ar.Parent,...)end)sendNotif("Hook Loaded\nby whited#4382",nil,5)end;sendNotif("API Loaded",nil,5)
