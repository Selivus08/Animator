local a={}a.ClassName="Maid"function a.new()return setmetatable({_tasks={}},a)end;function a.isMaid(b)return type(b)=="table"and b.ClassName=="Maid"end;function a:__index(c)if a[c]then return a[c]else return self._tasks[c]end end;function a:__newindex(c,d)if a[c]~=nil then error(("'%s' is reserved"):format(tostring(c)),2)end;local e=self._tasks;local f=e[c]if f==d then return end;e[c]=d;if f then if type(f)=="function"then f()elseif typeof(f)=="RBXScriptConnection"then f:Disconnect()elseif f.Destroy then f:Destroy()end end end;function a:GiveTask(g)if not g then error("Task cannot be false or nil",2)end;local h=#self._tasks+1;self[h]=g;if type(g)=="table"and not g.Destroy then warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n"..debug.traceback())end;return h end;function a:GivePromise(i)if not i:IsPending()then return i end;local j=i.resolved(i)local k=self:GiveTask(j)j:Finally(function()self[k]=nil end)return j end;function a:DoCleaning()local e=self._tasks;for c,g in pairs(e)do if typeof(g)=="RBXScriptConnection"then e[c]=nil;g:Disconnect()end end;local c,g=next(e)while g~=nil do e[c]=nil;if type(g)=="function"then g()elseif typeof(g)=="RBXScriptConnection"then g:Disconnect()elseif g.Destroy then g:Destroy()end;c,g=next(e)end end;a.Destroy=a.DoCleaning;local l=game:GetService("HttpService")local m=false;local n={}n.__index=n;n.ClassName="Signal"function n.new()local self=setmetatable({},n)self._bindableEvent=Instance.new("BindableEvent")self._argMap={}self._source=m and debug.traceback()or""self._bindableEvent.Event:Connect(function(o)self._argMap[o]=nil;if not self._bindableEvent and not next(self._argMap)then self._argMap=nil end end)return self end;function n:Fire(...)if not self._bindableEvent then warn(("Signal is already destroyed. %s"):format(self._source))return end;local p=table.pack(...)local o=l:GenerateGUID(false)self._argMap[o]=p;self._bindableEvent:Fire(o)end;function n:Connect(q)if not(type(q)=="function")then error(("connect(%s)"):format(typeof(q)),2)end;return self._bindableEvent.Event:Connect(function(o)local p=self._argMap[o]if p then q(table.unpack(p,1,p.n))else error("Missing arg data, probably due to reentrance.")end end)end;function n:Wait()local o=self._bindableEvent.Event:Wait()local p=self._argMap[o]if p then return table.unpack(p,1,p.n)else error("Missing arg data, probably due to reentrance.")return nil end end;function n:Destroy()if self._bindableEvent then self._bindableEvent:Destroy()self._bindableEvent=nil end;setmetatable(self,nil)end;local r=string.format;function sendNotif(s,t,u,v,w,x)game:GetService("StarterGui"):SetCore("SendNotification",{Title="Animator",Text=s.."\nBy hayper#0001"or nil,Icon=t or nil,Duration=u or nil,Button1=v or nil,Button2=w or nil,Callback=x or nil})end;function convertEnum(y)local z=tostring(y):split(".")if z[1]=="Enum"then local A=z[2]local B=z[3]local C={["PoseEasingDirection"]="EasingDirection",["PoseEasingStyle"]="EasingStyle"}if C[A]then return Enum[C[A]][B]else return y end else return y end end;function getBones(D,E)E=E or{}if typeof(D)~="Instance"then error(r("invalid argument 1 to 'getBones' (Instance expected, got %s)",typeof(D)))end;if typeof(E)~="table"then error(r("invalid argument 1 to 'getBones' (Table expected, got %s)",typeof(E)))end;local F={}local G=D:GetDescendants()for H=1,#G do local I=G[H]if not I:IsA("Bone")then continue end;local J=false;for K=1,#E do local L=E[K]if typeof(L)=="Instance"and I:IsDescendantOf(L)then J=true;break end end;if J~=true then table.insert(F,I)end end;return F end;function getMotors(D,E)E=E or{}if typeof(D)~="Instance"then error(r("invalid argument 1 to 'getMotors' (Instance expected, got %s)",typeof(D)))end;if typeof(E)~="table"then error(r("invalid argument 1 to 'getMotors' (Table expected, got %s)",typeof(E)))end;local M={}local G=D:GetDescendants()for H=1,#G do local I=G[H]if not I:IsA("Motor6D")or I.Part0==nil or I.Part1==nil then continue end;local J=false;for K=1,#E do local L=E[K]if typeof(L)=="Instance"and I:IsDescendantOf(L)then J=true;break end end;if J~=true then table.insert(M,I)end end;return M end;function parsePoseData(N)if not N:IsA("Pose")then error(r("invalid argument 1 to 'parsePoseData' (Pose expected, got %s)",N.ClassName))end;local O={Name=N.Name,CFrame=N.CFrame,EasingDirection=convertEnum(N.EasingDirection),EasingStyle=convertEnum(N.EasingStyle),Weight=N.Weight}if#N:GetChildren()>0 then O.Subpose={}local P=N:GetChildren()for H=1,#P do local A=P[H]if not A:IsA("Pose")then continue end;table.insert(O.Subpose,parsePoseData(A))end end;return O end;function parseKeyframeData(Q)if not Q:IsA("Keyframe")then error(r("invalid argument 1 to 'parseKeyframeData' (Keyframe expected, got %s)",Q.ClassName))end;local R={Name=Q.Name,Time=Q.Time,Pose={}}local P=Q:GetChildren()for H=1,#P do local A=P[H]if A:IsA("Pose")then table.insert(R.Pose,parsePoseData(A))elseif A:IsA("KeyframeMarker")then if not R["Marker"]then R.Marker={}end;if not R.Marker[A.Name]then R.Marker[A.Name]={}end;table.insert(R.Marker,A.Name)end end;return R end;function parseAnimationData(S)if not S:IsA("KeyframeSequence")then error(r("invalid argument 1 to 'parseAnimationData' (KeyframeSequence expected, got %s)",S.ClassName))end;local T={Loop=S.Loop,Priority=S.Priority,Frames={}}local P=S:GetChildren()for H=1,#P do local U=P[H]if not U:IsA("Keyframe")then continue end;table.insert(T.Frames,parseKeyframeData(U))end;table.sort(T.Frames,function(V,W)return V.Time<W.Time end)return T end;local X=game:GetService("TweenService")local Y=game:GetService("RunService")local Z={AnimationData={},handleVanillaAnimator=true,Character=nil,Looped=false,Length=0,Speed=1,IsPlaying=false,_motorIgnoreList={},_stopFadeTime=0.100000001,_playing=false,_stopped=false,_isLooping=false,_markerSignal={},_boneIgnoreList={}}local _,a0=CFrame.new,CFrame.Angles;local a1=math.deg;local a2=os.clock;local a3=_()local a4=_(0,0,0)*a0(a1(0),a1(0),a1(0))Z.__index=Z;function Z.new(D,a5)if typeof(D)~="Instance"then error(r("invalid argument 1 to 'new' (Instace expected, got %s)",typeof(D)))end;local self=setmetatable({},Z)if typeof(a5)=="string"or typeof(a5)=="number"then local a6=game:GetObjects("rbxassetid://"..tostring(a5))[1]if not a6:IsA("KeyframeSequence")then error("invalid argument 1 to 'new' (AnimationID expected)")end;self.AnimationData=parseAnimationData(a6)elseif typeof(a5)=="table"then self.AnimationData=a5 elseif typeof(a5)=="Instance"then if a5:IsA("KeyframeSequence")then self.AnimationData=parseAnimationData(a5)elseif a5:IsA("Animation")then local a6=game:GetObjects(a5.AnimationId)[1]if not a6:IsA("KeyframeSequence")then error("invalid argument 1 to 'new' (AnimationID inside Animation expected)")end;self.AnimationData=parseAnimationData(a6)end else error(r("invalid argument 2 to 'new' (number,string,table,Instance expected, got %s)",typeof(a5)))end;self.Character=D;self.Looped=self.AnimationData.Loop;self.Length=self.AnimationData.Frames[#self.AnimationData.Frames].Time;self._maid=a.new()self.DidLoop=n.new()self.Stopped=n.new()self.KeyframeReached=n.new()self._maid.DidLoop=self.DidLoop;self._maid.Stopped=self.Stopped;self._maid.KeyframeReached=self.KeyframeReached;return self end;function Z:IgnoreMotorIn(a7)if typeof(a7)~="table"then error(r("invalid argument 1 to 'IgnoreMotorIn' (Table expected, got %s)",typeof(a7)))end;self._motorIgnoreList=a7 end;function Z:GetMotorIgnoreList()return self._motorIgnoreList end;function Z:IgnoreBoneIn(a7)if typeof(a7)~="table"then error(r("invalid argument 1 to 'IgnoreBoneIn' (Table expected, got %s)",typeof(a7)))end;self._boneIgnoreList=a7 end;function Z:GetBoneIgnoreList()return self._boneIgnoreList end;function Z:_playPose(N,a8,a9)local M=getMotors(self.Character,self._motorIgnoreList)local F=getBones(self.Character,self._boneIgnoreList)if N.Subpose then local aa=N.Subpose;for H=1,#aa do local ab=aa[H]self:_playPose(ab,N,a9)end end;if not a8 then return end;local ac=TweenInfo.new(a9,N.EasingStyle,N.EasingDirection)coroutine.wrap(function()for H=1,#M do local ad=M[H]if ad.Part0.Name~=a8.Name or ad.Part1.Name~=N.Name then continue end;if self==nil or self._stopped then break end;if a9>0 then X:Create(ad,ac,{Transform=N.CFrame}):Play()else ad.Transform=N.CFrame end end end)()coroutine.wrap(function()for H=1,#F do local ae=F[H]if a8.Name~=ae.Parent.Name or ae.Name~=N.Name then continue end;if self==nil or self._stopped then break end;if a9>0 then X:Create(ae,ac,{Transform=N.CFrame}):Play()else ae.Transform=N.CFrame end end end)()end;function Z:Play(af,ag,ah)af=af or 0.100000001;if self._playing and not self._isLooping then return end;self._playing=true;self._isLooping=false;self.IsPlaying=true;local ai;local aj;if not self.Character then return end;if self.Character:FindFirstChild("Humanoid")then ai=self.Character.Humanoid.Died:Connect(function()self:Destroy()ai:Disconnect()end)if self.handleVanillaAnimator and self.Character.Humanoid:FindFirstChild("Animator")then self.Character.Humanoid.Animator:Destroy()end end;aj=self.Character:GetPropertyChangedSignal("Parent"):Connect(function()if self~=nil and self.Character.Parent~=nil then return end;self:Destroy()aj:Disconnect()end)if self==nil or self.Character.Parent==nil then return end;local ak=a2()coroutine.wrap(function()for I=1,#self.AnimationData.Frames do local U=self.AnimationData.Frames[I]if self==nil or self._stopped then break end;local al=U.Time/(ah or self.Speed)if U.Name~="Keyframe"then self.KeyframeReached:Fire(U.Name)end;if U["Marker"]then for am,B in next,U.Marker do if not self._markerSignal[am]then continue end;self._markerSignal[am]:Fire(B)end end;if U.Pose then local an=U.Pose;for H=1,#an do local A=an[H]local ao=af;if I~=1 then ao=(al*(ah or self.Speed)-self.AnimationData.Frames[I-1].Time)/(ah or self.Speed)end;self:_playPose(A,nil,ao)end end;if al>a2()-ak then repeat Y.Stepped:Wait()until self==nil or self._stopped or a2()-ak>=al end end;if self==nil then return end;if self.Looped and not self._stopped then self.DidLoop:Fire()self._isLooping=true;return self:Play(af,ag,ah)end;Y.Stepped:Wait()local ac=TweenInfo.new(self._stopFadeTime or af,Enum.EasingStyle.Cubic,Enum.EasingDirection.InOut)if self.Character then local M=getMotors(self.Character,self._motorIgnoreList)local F=getBones(self.Character,self._boneIgnoreList)for H=1,#M do local W=M[H]if(self._stopFadeTime or af)>0 then X:Create(W,ac,{Transform=a3,CurrentAngle=0}):Play()else W.CurrentAngle=0;W.Transform=a3 end end;for H=1,#F do local ap=F[H]if(self._stopFadeTime or af)>0 then X:Create(ap,ac,{Transform=a4}):Play()else ap.Transform=a4 end end;if self.handleVanillaAnimator and self.Character:FindFirstChild("Humanoid")and not self.Character.Humanoid:FindFirstChildOfClass("Animator")then Instance.new("Animator",self.Character.Humanoid)end end;if ai then ai:Disconnect()end;aj:Disconnect()self._stopped=false;self._playing=false;self.IsPlaying=false;self.Stopped:Fire()end)()end;function Z:GetTimeOfKeyframe(aq)for H=1,#self.AnimationData.Frames do local U=self.AnimationData.Frames[H]if U.Name~=aq then continue end;return U.Time end;return math.huge end;function Z:GetMarkerReachedSignal(ar)if not self._markerSignal[ar]then self._markerSignal[ar]=n.new()end;return self._markerSignal[ar]end;function Z:AdjustSpeed(ah)self.Speed=ah end;function Z:Stop(af)self._stopFadeTime=af or 0.100000001;self._stopped=true end;function Z:Destroy()self:Stop(0)self.Stopped:Wait()self._maid:DoCleaning()setmetatable(self,nil)end;getgenv().Animator=Z;getgenv().hookAnimatorFunction=function()local as;as=hookmetamethod(game,"__namecall",function(at,...)local au=getnamecallmethod()if not checkcaller()or at.ClassName~="Humanoid"or au~="LoadAnimation"then return as(at,...)end;local p={...}if not p[2]or p[2]==true then return as(at,...)end;return Z.new(at.Parent,...)end)sendNotif("Hook Loaded\nby whited#4382",nil,5)end;sendNotif("API Loaded",nil,5)